
function _debugTodayChecksForMe() {
  const ss = master_();
  const id = getCurrentAnalystId_();
  const today = Utilities.formatDate(new Date(), TZ, 'yyyy-MM-dd');

  // Count from CheckEvents
  const ceRows = readRows_(ss.getSheetByName(SHEETS.CHECK_EVENTS))
    .filter(r => r.date_str === today && r.analyst_id_norm === id);
  const ceCount = ceRows.length;

  // Inspect Live headers & current value
  const live = ss.getSheetByName(SHEETS.LIVE);
  const out = { today, me: id, ceCount, liveHeaderOk: false, liveTodayChecksValue: null, notes: [] };
  if (!live || live.getLastRow() < 2) {
    out.notes.push('LIVE sheet missing or empty.');
    Logger.log(out); return out;
  }
  const vals = live.getDataRange().getValues();
  const hdr = vals[0].map(String);
  const L = indexMap_(hdr);
  if (L['today_checks'] == null) {
    out.notes.push('LIVE header "today_checks" not found. Header drift?');
  } else {
    out.liveHeaderOk = true;
  }

  let rowIndex = -1;
  for (let r=1; r<vals.length; r++) {
    if (normId_(vals[r][L['analyst_id']]) === id) { rowIndex = r; break; }
  }
  if (rowIndex === -1) {
    out.notes.push('No LIVE row for you yet.');
  } else if (out.liveHeaderOk) {
    out.liveTodayChecksValue = vals[rowIndex][L['today_checks']];
  }

  Logger.log(out);
  return out;
}


/**
 * Canonical Live headers (must match exactly, in order).
 */
function __LIVE_HEADERS__() {
  return [
    'analyst_id','name','team','online','last_seen_iso','state','since_iso',
    'mins_in_state','today_checks','baseline_hours','location_today','session_token',
    'logged_in_mins','live_efficiency_pct','live_utilisation_pct','live_throughput_per_hr'
  ];
}

/**
 * Ensure Live has the canonical headers (exact text/order).
 */
function __ensureLiveHeadersExact__() {
  const ss = master_();
  const sh = ss.getSheetByName(SHEETS.LIVE) || ss.insertSheet(SHEETS.LIVE);
  const HEAD = __LIVE_HEADERS__();

  // Create/repair header row
  const width = Math.max(HEAD.length, sh.getLastColumn() || 1);
  const cur = sh.getRange(1, 1, 1, width).getValues()[0].map(String);
  for (let i = 0; i < HEAD.length; i++) {
    if ((cur[i] || '').trim() !== HEAD[i]) {
      sh.getRange(1, i + 1).setValue(HEAD[i]);
    }
  }
  sh.setFrozenRows(1);
  return sh;
}

/**
 * Keep only ONE Live row per analyst_id (normalised).
 * We keep the row with the most-recent last_seen_iso, delete the rest.
 * Then we run refreshLiveFor_ for each analyst to make the row consistent.
 */
function RUN_FIX_LIVE_DUPES() {
  const ss = master_();
  const sh = __ensureLiveHeadersExact__();
  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return { ok: true, kept: 0, deleted: 0 };

  const hdr = v[0].map(String);
  const H = {};
  hdr.forEach((h, i) => H[h] = i);

  const byAnalyst = new Map(); // id_norm -> {rowIndex, lastSeen, values}
  for (let r = 1; r < v.length; r++) {
    const row = v[r];
    const id = String(row[H['analyst_id']] || '').toLowerCase().trim();
    if (!id) continue;

    const lastSeenIso = String(row[H['last_seen_iso']] || '');
    const lastSeen = lastSeenIso ? new Date(lastSeenIso) : new Date(0);

    const cur = byAnalyst.get(id);
    if (!cur || (lastSeen > cur.lastSeen)) {
      byAnalyst.set(id, { rowIndex: r + 1, lastSeen, values: row });
    }
  }

  // Build a set of rows to keep
  const keep = new Set(Array.from(byAnalyst.values()).map(o => o.rowIndex));

  // Rebuild the sheet with only header + kept rows
  const keptRows = [];
  for (let r = 1; r < v.length; r++) {
    const rowIndex = r + 1;
    if (keep.has(rowIndex)) keptRows.push(v[r]);
  }

  sh.clearContents();
  sh.getRange(1, 1, 1, hdr.length).setValues([hdr]);
  if (keptRows.length) sh.getRange(2, 1, keptRows.length, hdr.length).setValues(keptRows);

  // Refresh each analyst we kept to ensure a consistent single-row snapshot
  const ids = Array.from(byAnalyst.keys());
  ids.forEach(id => { try { refreshLiveFor_(id); } catch (e) {} });

  return { ok: true, kept: keptRows.length, deleted: (v.length - 1) - keptRows.length };
}

function DEBUG_ListTLExports(){
  try {
    Logger.log('TL is ' + (typeof TL));
    if (typeof TL === 'object' && TL) {
      var keys = Object.keys(TL).sort();
      Logger.log('TL keys (' + keys.length + '): ' + keys.join(', '));
      Logger.log('Calendar fn exists? ' + (typeof TL.getStateCalendarForAnalyst));
      Logger.log('Stats fn exists? ' + (typeof TL.getStatsForAnalyst));
    }
  } catch (e) {
    Logger.log('Error inspecting TL: ' + e);
  }
}

function DEBUG_CallTL(){
  try {
    var me = Session.getActiveUser().getEmail();
    Logger.log('Me: ' + me);
    if (TL && typeof TL.getStateCalendarForAnalyst === 'function') {
      var cal = TL.getStateCalendarForAnalyst(me, '2025-01-01', '2025-01-07');
      Logger.log('Calendar OK: ' + JSON.stringify(cal).slice(0,200));
    } else {
      Logger.log('TL.getStateCalendarForAnalyst is not a function');
    }
    if (TL && typeof TL.getStatsForAnalyst === 'function') {
      var st = TL.getStatsForAnalyst(me, '2025-01-01');
      Logger.log('Stats OK: ' + JSON.stringify(st).slice(0,200));
    } else {
      Logger.log('TL.getStatsForAnalyst is not a function');
    }
  } catch (e) {
    Logger.log('DEBUG_CallTL error: ' + (e && e.message || e));
  }
}

function _libSmokeTest() {
  const tz = Session.getScriptTimeZone();
  const today = Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');

  Logger.log('typeof TL_LIB:', typeof TL_LIB);
  Logger.log('typeof TL_LIB.getStateCalendarForAnalyst:', typeof TL_LIB.getStateCalendarForAnalyst);
  Logger.log('typeof TL_LIB.getStatsForAnalyst:', typeof TL_LIB.getStatsForAnalyst);

  // If types are "function", try calling them:
  if (typeof TL_LIB.getStateCalendarForAnalyst === 'function') {
    const cal = TL_LIB.getStateCalendarForAnalyst('', today, today);
    Logger.log('Cal OK: ' + JSON.stringify(cal).slice(0, 500));
  }
  if (typeof TL_LIB.getStatsForAnalyst === 'function') {
    const stats = TL_LIB.getStatsForAnalyst('', today);
    Logger.log('Stats OK: ' + JSON.stringify(stats).slice(0, 500));
  }
}

function _listTLLibExports() {
  try {
    const names = Object.getOwnPropertyNames(TL_LIB);
    Logger.log('TL_LIB keys: ' + names.join(', '));
  } catch (e) {
    Logger.log('Keys error: ' + e);
  }
}

function _libSmokeTest_fixed() {
  const asStr = v => (typeof v === 'undefined' ? 'undefined' : String(v));
  Logger.log('typeof TL_LIB = ' + (typeof TL_LIB));
  Logger.log('typeof TL_LIB.getStateCalendarForAnalyst = ' + (TL_LIB ? typeof TL_LIB.getStateCalendarForAnalyst : 'n/a'));
  Logger.log('typeof TL_LIB.getStatsForAnalyst = ' + (TL_LIB ? typeof TL_LIB.getStatsForAnalyst : 'n/a'));

  try {
    const keys = TL_LIB ? Object.getOwnPropertyNames(TL_LIB) : [];
    Logger.log('TL_LIB keys: ' + keys.join(', '));
  } catch (e) {
    Logger.log('TL_LIB keys error: ' + e);
  }
}


function _checkBoth() {
  Logger.log('typeof TL = ' + (typeof TL));
  Logger.log('typeof TL_LIB = ' + (typeof TL_LIB));
}

function _pingTL()
{Logger.log(JSON.stringify(TL_LIB.ping()));}
